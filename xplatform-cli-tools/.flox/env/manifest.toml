# this is a   f l o x   manifest.
# visit flox.dev/docs/concepts/manifest/
# or see flox-edit(1), manifest.toml(5) for more information.
version = 1

[install]
_1password.pkg-path = "_1password"
awscli2.pkg-path = "awscli2"
gh.pkg-path = "gh"
gitFull.pkg-path = "gitFull"
gum.pkg-path = "gum"
bat.pkg-path = "bat"
curl.pkg-path = "curl"

[vars]
# 1password github config
OP_GITHUB_VAULT = "1password"           # name of 1password vault containing github token(s)
OP_GITHUB_TOKEN_ITEM = "repo"    # name of the item storing github token(s)
OP_GITHUB_TOKEN_FIELD = "token"               # field name containing the github token(s)

# 1password aws config
OP_AWS_VAULT = "1password"              # name of 1password vault containing aws creds
OP_AWS_CREDENTIALS_ITEM = "awskeyz"   # name of the item storing aws creds
OP_AWS_USERNAME_FIELD = "username"            # field name for aws access key ID
OP_AWS_CREDENTIALS_FIELD = "credential"      # field name for aws secret access key

[hook]
on-activate = '''
# 1password auth with CI support
detect_environment() {
  # detect github actions if a thing
  if [[ -n "$GITHUB_ACTIONS" ]]; then
    echo "github_actions"
    return 0
  fi
  
  # add detection for other CI platforms if needed; e.g.:
  # if [[ -n "$CIRCLECI" ]]; then
  #   echo "circle_ci"
  #   return 0
  # fi
  
  # if no CI -> then we're local
  echo "local"
  return 0
}

authenticate_1password() {
  SESSION_FILE="$HOME/.config/op/1password-session.token"

  # do we/do we not already have a valid session? we use files + tokens for local, env vars for CI
  local env=$(detect_environment)

  if [[ "$env" == "local" ]]; then
    # are we/are we not local? we check for a file-based token
    if [[ -f "$SESSION_FILE" ]] && OP_SESSION_TOKEN=$(cat "$SESSION_FILE") && op whoami --session "$OP_SESSION_TOKEN" >/dev/null 2>&1; then
      export OP_SESSION_TOKEN
      return 0
    fi

    # oh snap! we do not have a valid session; user needs to run 'op-login' function
    return 1
  else
    # are we/are we not in CI? we check for existing token in env var
    if [[ -n "$OP_SESSION_TOKEN" ]] && op whoami --session "$OP_SESSION_TOKEN" >/dev/null 2>&1; then
      return 0
    fi

    # we are in CI: setup logic for github actions
    if [[ -z "$OP_SERVICE_ACCOUNT_TOKEN" ]]; then
      echo "‚ö†Ô∏è  OP_SERVICE_ACCOUNT_TOKEN is not set. 1Password authentication unavailable in CI."
      return 1
    fi

    if OP_SESSION_TOKEN=$(op signin --raw --service-account-token "$OP_SERVICE_ACCOUNT_TOKEN" 2>/dev/null); then
      export OP_SESSION_TOKEN
      return 0
    else
      echo "‚ö†Ô∏è  Failed to authenticate with 1Password service account"
      return 1
    fi
  fi

  return 1
}

detect_1password_state() {
  # are we/are we not auth-ed?
  if [[ -n "$(op whoami 2>/dev/null)" ]]; then
    export OP_STATE="authenticated"
    return 0
  fi

  # are/are not accounts configured (we're looking for non-empty output)
  if [[ -n "$(op account list 2>/dev/null)" ]]; then
    export OP_STATE="needs_login"
    return 0
  fi

  # oops: no accounts configured
  export OP_STATE="needs_setup"
  return 0
}

# let's try to auth; this is non-blocking: i.e., not being auth-ed doesn't fail activation
authenticate_1password || true
detect_1password_state

# create shell-specific wrapper files
mkdir -p "${FLOX_ENV_CACHE}/shell"

# bash wrapper file
cat > "${FLOX_ENV_CACHE}/shell/wrapper.bash" << 'EOBASH'
# load 1password session token - check env var first, then file
[[ -z "$OP_SESSION_TOKEN" && -f "$HOME/.config/op/1password-session.token" ]] && export OP_SESSION_TOKEN=$(cat "$HOME/.config/op/1password-session.token")

# gh wrapper function
gh() {
  if [[ -n "$OP_SESSION_TOKEN" ]]; then
    op run --session "$OP_SESSION_TOKEN" --env-file <(echo "GITHUB_TOKEN=op://$OP_GITHUB_VAULT/$OP_GITHUB_TOKEN_ITEM/$OP_GITHUB_TOKEN_FIELD") -- gh "$@"
  else
    case "$OP_STATE" in
      needs_setup)
        echo "‚ö†Ô∏è  1Password not configured. Run 'op-setup' for automated setup."
        ;;
      needs_login)
        echo "‚ö†Ô∏è  Not signed in to 1Password. Run 'op-login'"
        ;;
      *)
        echo "‚ö†Ô∏è  1Password unavailable. Run 'op-setup'"
        ;;
    esac
    echo "Falling back to standard gh authentication..."
    command gh "$@"
  fi
}

# git wrapper function
git() {
  if [[ "$1" =~ ^(push|pull|fetch|clone|remote)$ ]] && [[ -n "$OP_SESSION_TOKEN" ]]; then
    token=$(op read "op://$OP_GITHUB_VAULT/$OP_GITHUB_TOKEN_ITEM/$OP_GITHUB_TOKEN_FIELD" --session "$OP_SESSION_TOKEN" 2>/dev/null)
    if [[ -n "$token" ]]; then
      askpass=$(mktemp)
      
      # set up cleanup trap for our temp file
      trap 'rm -f "$askpass"' EXIT INT TERM
      
      echo -e "#!/bin/sh\necho $token" > "$askpass"
      chmod 700 "$askpass"
      GIT_ASKPASS="$askpass" GIT_TERMINAL_PROMPT=0 command git -c credential.helper= "$@"
      status=$?
      
      # manually remove temp file + clear the trap
      rm -f "$askpass"
      trap - EXIT INT TERM
      
      return $status
    fi
  fi
  command git "$@"
}

# aws wrapper function
aws() {
  if [[ -n "$OP_SESSION_TOKEN" ]]; then
    op run --session "$OP_SESSION_TOKEN" --env-file <(echo -e "AWS_ACCESS_KEY_ID=op://$OP_AWS_VAULT/$OP_AWS_CREDENTIALS_ITEM/$OP_AWS_USERNAME_FIELD\nAWS_SECRET_ACCESS_KEY=op://$OP_AWS_VAULT/$OP_AWS_CREDENTIALS_ITEM/$OP_AWS_CREDENTIALS_FIELD") -- aws "$@"
  else
    case "$OP_STATE" in
      needs_setup)
        echo "‚ö†Ô∏è  1Password not configured. Run 'op-setup' for automated setup."
        ;;
      needs_login)
        echo "‚ö†Ô∏è  Not signed in to 1Password. Run 'op-login'"
        ;;
      *)
        echo "‚ö†Ô∏è  1Password unavailable. Run 'op-setup'"
        ;;
    esac
    echo "Falling back to standard aws authentication..."
    command aws "$@"
  fi
}
EOBASH
chmod +x "${FLOX_ENV_CACHE}/shell/wrapper.bash"

# zsh wrapper file - with zsh-specific syntax
cat > "${FLOX_ENV_CACHE}/shell/wrapper.zsh" << 'EOZSH'
# load 1password session token - check env var first, then file
[[ -z "$OP_SESSION_TOKEN" && -f "$HOME/.config/op/1password-session.token" ]] && export OP_SESSION_TOKEN=$(cat "$HOME/.config/op/1password-session.token")

# gh wrapper function
function gh() {
  if [[ -n "$OP_SESSION_TOKEN" ]]; then
    op run --session "$OP_SESSION_TOKEN" --env-file =(echo "GITHUB_TOKEN=op://$OP_GITHUB_VAULT/$OP_GITHUB_TOKEN_ITEM/$OP_GITHUB_TOKEN_FIELD") -- gh "$@"
  else
    case "$OP_STATE" in
      needs_setup)
        echo "‚ö†Ô∏è  1Password not configured. Run 'op-setup' for automated setup."
        ;;
      needs_login)
        echo "‚ö†Ô∏è  Not signed in to 1Password. Run 'op-login'"
        ;;
      *)
        echo "‚ö†Ô∏è  1Password unavailable. Run 'op-setup'"
        ;;
    esac
    echo "Falling back to standard gh authentication..."
    command gh "$@"
  fi
}

# git wrapper function
function git() {
  if [[ "$1" =~ ^(push|pull|fetch|clone|remote)$ ]] && [[ -n "$OP_SESSION_TOKEN" ]]; then
    token=$(op read "op://$OP_GITHUB_VAULT/$OP_GITHUB_TOKEN_ITEM/$OP_GITHUB_TOKEN_FIELD" --session "$OP_SESSION_TOKEN" 2>/dev/null)
    if [[ -n "$token" ]]; then
      askpass=$(mktemp)
      
      # Set up cleanup trap for the temporary file (zsh syntax)
      trap 'rm -f "$askpass"' EXIT INT TERM
      
      # Write token to file with more secure permissions
      print -n "#!/bin/sh\necho $token" > "$askpass"
      chmod 700 "$askpass"
      GIT_ASKPASS="$askpass" GIT_TERMINAL_PROMPT=0 command git -c credential.helper= "$@"
      status=$?
      
      # Manually remove the file and clear the trap
      rm -f "$askpass"
      trap - EXIT INT TERM
      
      return $status
    fi
  fi
  command git "$@"
}

# aws wrapper function
function aws() {
  if [[ -n "$OP_SESSION_TOKEN" ]]; then
    op run --session "$OP_SESSION_TOKEN" --env-file =(echo "AWS_ACCESS_KEY_ID=op://$OP_AWS_VAULT/$OP_AWS_CREDENTIALS_ITEM/$OP_AWS_USERNAME_FIELD\nAWS_SECRET_ACCESS_KEY=op://$OP_AWS_VAULT/$OP_AWS_CREDENTIALS_ITEM/$OP_AWS_CREDENTIALS_FIELD") -- aws "$@"
  else
    case "$OP_STATE" in
      needs_setup)
        echo "‚ö†Ô∏è  1Password not configured. Run 'op-setup' for automated setup."
        ;;
      needs_login)
        echo "‚ö†Ô∏è  Not signed in to 1Password. Run 'op-login'"
        ;;
      *)
        echo "‚ö†Ô∏è  1Password unavailable. Run 'op-setup'"
        ;;
    esac
    echo "Falling back to standard aws authentication..."
    command aws "$@"
  fi
}
EOZSH
chmod +x "${FLOX_ENV_CACHE}/shell/wrapper.zsh"

# fish wrapper file
cat > "${FLOX_ENV_CACHE}/shell/wrapper.fish" << 'EOFISH'
# load 1password session token - check env var first, then file
if test -z "$OP_SESSION_TOKEN"; and test -f "$HOME/.config/op/1password-session.token"
    set -gx OP_SESSION_TOKEN (cat "$HOME/.config/op/1password-session.token")
end

# gh wrapper function
function gh
    if test -n "$OP_SESSION_TOKEN"
        op run --session "$OP_SESSION_TOKEN" --env-file (echo "GITHUB_TOKEN=op://$OP_GITHUB_VAULT/$OP_GITHUB_TOKEN_ITEM/$OP_GITHUB_TOKEN_FIELD" | psub) -- gh $argv
    else
        switch "$OP_STATE"
            case needs_setup
                echo "‚ö†Ô∏è  1Password not configured. Run 'op-setup' for automated setup."
            case needs_login
                echo "‚ö†Ô∏è  Not signed in to 1Password. Run 'op-login'"
            case '*'
                echo "‚ö†Ô∏è  1Password unavailable. Run 'op-setup'"
        end
        echo "Falling back to standard gh authentication..."
        command gh $argv
    end
end

# git wrapper function
function git
    if contains -- $argv[1] push pull fetch clone remote; and test -n "$OP_SESSION_TOKEN"
        set -l token (op read "op://$OP_GITHUB_VAULT/$OP_GITHUB_TOKEN_ITEM/$OP_GITHUB_TOKEN_FIELD" --session "$OP_SESSION_TOKEN" 2>/dev/null)
        if test -n "$token"
            # Create temporary file
            set -l askpass (mktemp)
            
            # Define cleanup function
            function cleanup --on-event fish_exit --on-signal INT --on-signal TERM
                rm -f $askpass
            end
            
            echo -e "#!/bin/sh\necho $token" > "$askpass"
            chmod 700 "$askpass"
            env GIT_ASKPASS="$askpass" GIT_TERMINAL_PROMPT=0 command git -c credential.helper= $argv
            set -l git_status $status
            
            # Cleanup temporary file and function
            rm -f "$askpass"
            functions -e cleanup
            
            return $git_status
        end
    end
    command git $argv
end

# aws wrapper function
function aws
    if test -n "$OP_SESSION_TOKEN"
        op run --session "$OP_SESSION_TOKEN" --env-file (echo -e "AWS_ACCESS_KEY_ID=op://$OP_AWS_VAULT/$OP_AWS_CREDENTIALS_ITEM/$OP_AWS_USERNAME_FIELD\nAWS_SECRET_ACCESS_KEY=op://$OP_AWS_VAULT/$OP_AWS_CREDENTIALS_ITEM/$OP_AWS_CREDENTIALS_FIELD" | psub) -- aws $argv
    else
        switch "$OP_STATE"
            case needs_setup
                echo "‚ö†Ô∏è  1Password not configured. Run 'op-setup' for automated setup."
            case needs_login
                echo "‚ö†Ô∏è  Not signed in to 1Password. Run 'op-login'"
            case '*'
                echo "‚ö†Ô∏è  1Password unavailable. Run 'op-setup'"
        end
        echo "Falling back to standard aws authentication..."
        command aws $argv
    end
end
EOFISH
chmod +x "${FLOX_ENV_CACHE}/shell/wrapper.fish"

  # Fetch README.md if not present
  README_FILE="$FLOX_ENV_PROJECT/README.md"
  if [ ! -f "$README_FILE" ]; then
    if curl -fsSL https://raw.githubusercontent.com/barstoolbluz/floxenvs/main/xplatform-cli-tools/README.md -o "$README_FILE" 2>/dev/null; then
      echo "‚úì Downloaded README.md (use 'helpf' to view)"
    fi
  fi

# informational message; comment-out or delete 'show_help' under # runnit to disable
show_help() {
    # Check authentication status based on OP_STATE
    local auth_status=""
    case "$OP_STATE" in
      authenticated)
        auth_status="$(gum style --foreground 82 '‚úÖ Authenticated')"
        ;;
      needs_login)
        auth_status="$(gum style --foreground 214 '‚ö†Ô∏è  Account configured - run') $(gum style --foreground 212 'op-login')"
        ;;
      needs_setup)
        auth_status="$(gum style --foreground 196 '‚ùå Not configured - run') $(gum style --foreground 212 'op-setup')"
        ;;
      *)
        auth_status="$(gum style --foreground 214 '‚ö†Ô∏è  Unknown state - run') $(gum style --foreground 212 'op-setup')"
        ;;
    esac

    gum style \
        --border rounded \
        --border-foreground 240 \
        --padding "1 2" \
        --margin "1 0" \
        --width 96 \
        "$(gum style --foreground 141 --bold 'This is a  F l o x  environment for AWS and GitHub CLI')

üëâ  Getting Help:
    $(gum style --foreground 212 'helpf')       Display this help message

üëâ  Integrated Tools:
    $(gum style --foreground 212 'aws')         AWS CLI with 1Password credentials
    $(gum style --foreground 212 'gh')          GitHub CLI with 1Password auth
    $(gum style --foreground 212 'git')         Git with 1Password auth for remote operations

üëâ  Usage Tips:
    ‚Ä¢ Use $(gum style --foreground 212 'aws'), $(gum style --foreground 212 'gh'), and $(gum style --foreground 212 'git') interactively as normal
    ‚Ä¢ In scripts, source the shell wrapper files from:
      $(gum style --foreground 212 "\$FLOX_ENV_CACHE/shell/wrapper.[bash|zsh|fish]")
    ‚Ä¢ Bypass wrappers with $(gum style --foreground 212 'command aws'), $(gum style --foreground 212 'command gh'), or $(gum style --foreground 212 'command git')

üëâ  Authentication:
    Status: $auth_status
    ‚Ä¢ Run $(gum style --foreground 212 'op-setup') for first-time setup, or $(gum style --foreground 212 'op-login') to sign in
    ‚Ä¢ Credentials are fetched securely from 1Password when needed"

    echo ""
}

# runnit
show_help
'''

[profile]
bash = '''
# source 1password wrapper functions
[[ -f "${FLOX_ENV_CACHE}/shell/wrapper.bash" ]] && source "${FLOX_ENV_CACHE}/shell/wrapper.bash"

  helpf() {
    local README_FILE="$FLOX_ENV_PROJECT/README.md"
    local README_URL="https://raw.githubusercontent.com/barstoolbluz/floxenvs/main/xplatform-cli-tools/README.md"

    if [ "$1" = "--help" ]; then
      echo "Usage: helpf [OPTIONS]"
      echo ""
      echo "View environment documentation"
      echo ""
      echo "Options:"
      echo "  --force    Force download fresh copy from GitHub"
      echo "  --help     Show this help message"
      echo ""
      echo "The README is cached locally and only downloaded if missing."
      return 0
    fi

    if [ "$1" = "--force" ]; then
      echo "Fetching latest README.md from GitHub..."
      if curl -fsSL "$README_URL" -o "$README_FILE"; then
        echo "‚úì Downloaded README.md"
      else
        echo "‚úó Failed to download README.md"
        return 1
      fi
    elif [ ! -f "$README_FILE" ]; then
      echo "README.md not found, downloading..."
      if curl -fsSL "$README_URL" -o "$README_FILE"; then
        echo "‚úì Downloaded README.md"
      else
        echo "‚úó Failed to download README.md"
        return 1
      fi
    fi

    if [ -f "$README_FILE" ]; then
      bat --style=auto --paging=always "$README_FILE"
    else
      echo "‚úó README.md not found at $README_FILE"
      return 1
    fi
  }

# bootstrap 1password cli setup
op-bootstrap() {
  gum style --border rounded "üîê 1Password CLI Setup"
  echo ""
  echo "Collect your 1Password credentials to set up CLI access."
  echo "You'll need: Sign-in address, Email, Secret Key, and Master Password"
  echo ""

  # get creds
  local address=$(gum input --placeholder "account.1password.com" --prompt "Sign-in address: ")
  local email=$(gum input --placeholder "email@example.com" --prompt "Email: ")
  local secret_key=$(gum input --password --prompt "Secret Key (A3-XXXXXX-...): ")
  local password=$(gum input --password --prompt "Master password: ")
  local shorthand=$(gum input --placeholder "personal" --prompt "Account shorthand: " --value "$(echo "$address" | cut -d. -f1)")

  # validate inputs
  if [[ -z "$address" ]] || [[ -z "$email" ]] || [[ -z "$secret_key" ]] || [[ -z "$password" ]]; then
    echo "‚ùå All fields are required"
    return 1
  fi

  if [[ ! "$secret_key" =~ ^A3- ]]; then
    echo "‚ùå Invalid Secret Key format (should start with A3-)"
    return 1
  fi

  echo ""
  echo "Setting up 1Password account..."

  # add account using env var
  if ! OP_SECRET_KEY="$secret_key" op account add \
    --shorthand "$shorthand" \
    --address "$address" \
    --email "$email" 2>/dev/null; then
    echo "‚ùå Failed to add account. Check your credentials."
    unset password secret_key
    return 1
  fi

  # sign in
  local session_token
  if ! session_token=$(printf "%s\n" "$password" | op signin --account "$shorthand" --raw 2>/dev/null); then
    echo "‚ùå Failed to authenticate. Check your password."
    unset password secret_key
    return 1
  fi

  # store session token
  local session_file="$HOME/.config/op/1password-session.token"
  mkdir -p "$(dirname "$session_file")"
  echo "$session_token" > "$session_file"
  chmod 600 "$session_file"
  export OP_SESSION_TOKEN="$session_token"

  # clear sensitive vars
  unset password secret_key

  echo "‚úÖ 1Password CLI configured and authenticated!"
  return 0
}

# smart setup dispatcher
op-setup() {
  case "$OP_STATE" in
    authenticated)
      echo "‚úÖ Already authenticated with 1Password"
      op whoami
      ;;
    needs_login)
      echo "‚úÖ Account configured. Running login..."
      op-login
      ;;
    needs_setup)
      echo "No 1Password account configured."
      if gum confirm "Set up 1Password CLI now?" --default=true; then
        op-bootstrap
      fi
      ;;
    *)
      echo "‚ùå Unexpected state: $OP_STATE"
      return 1
      ;;
  esac
}

# interactive 1password login
op-login() {
  local SESSION_FILE="$HOME/.config/op/1password-session.token"

  # check does account exist? (we're looking for non-empty output)
  if [[ -z "$(op account list 2>/dev/null)" ]]; then
    echo "‚ö†Ô∏è  No 1Password account configured."
    if gum confirm "Set up 1Password CLI now?" --default=true; then
      op-bootstrap
      return $?
    fi
    return 1
  fi

  # try auth
  for i in {1..3}; do
    if OP_SESSION_TOKEN=$(op signin --raw 2>/dev/null); then
      mkdir -p "$(dirname "$SESSION_FILE")"
      echo "$OP_SESSION_TOKEN" > "$SESSION_FILE"
      chmod 600 "$SESSION_FILE"
      export OP_SESSION_TOKEN
      echo "‚úÖ Successfully authenticated with 1Password"
      return 0
    fi
    [[ $i -eq 3 ]] && { echo "‚ùå Authentication failed after 3 attempts."; return 1; } || echo "‚ö†Ô∏è  Attempt $i failed. Try again."
  done
}
'''

zsh = '''
# source 1password wrapper functions
[[ -f "${FLOX_ENV_CACHE}/shell/wrapper.zsh" ]] && source "${FLOX_ENV_CACHE}/shell/wrapper.zsh"

  helpf() {
    local README_FILE="$FLOX_ENV_PROJECT/README.md"
    local README_URL="https://raw.githubusercontent.com/barstoolbluz/floxenvs/main/xplatform-cli-tools/README.md"

    if [ "$1" = "--help" ]; then
      echo "Usage: helpf [OPTIONS]"
      echo ""
      echo "View environment documentation"
      echo ""
      echo "Options:"
      echo "  --force    Force download fresh copy from GitHub"
      echo "  --help     Show this help message"
      echo ""
      echo "The README is cached locally and only downloaded if missing."
      return 0
    fi

    if [ "$1" = "--force" ]; then
      echo "Fetching latest README.md from GitHub..."
      if curl -fsSL "$README_URL" -o "$README_FILE"; then
        echo "‚úì Downloaded README.md"
      else
        echo "‚úó Failed to download README.md"
        return 1
      fi
    elif [ ! -f "$README_FILE" ]; then
      echo "README.md not found, downloading..."
      if curl -fsSL "$README_URL" -o "$README_FILE"; then
        echo "‚úì Downloaded README.md"
      else
        echo "‚úó Failed to download README.md"
        return 1
      fi
    fi

    if [ -f "$README_FILE" ]; then
      bat --style=auto --paging=always "$README_FILE"
    else
      echo "‚úó README.md not found at $README_FILE"
      return 1
    fi
  }

# bootstrap 1password cli setup
op-bootstrap() {
  gum style --border rounded "üîê 1Password CLI Setup"
  echo ""
  echo "Collect your 1Password credentials to set up CLI access."
  echo "You'll need: Sign-in address, Email, Secret Key, and Master Password"
  echo ""

  # collect creds
  local address=$(gum input --placeholder "account.1password.com" --prompt "Sign-in address: ")
  local email=$(gum input --placeholder "email@example.com" --prompt "Email: ")
  local secret_key=$(gum input --password --prompt "Secret Key (A3-XXXXXX-...): ")
  local password=$(gum input --password --prompt "Master password: ")
  local shorthand=$(gum input --placeholder "personal" --prompt "Account shorthand: " --value "$(echo "$address" | cut -d. -f1)")

  # validate inputs
  if [[ -z "$address" ]] || [[ -z "$email" ]] || [[ -z "$secret_key" ]] || [[ -z "$password" ]]; then
    echo "‚ùå All fields are required"
    return 1
  fi

  if [[ ! "$secret_key" =~ ^A3- ]]; then
    echo "‚ùå Invalid Secret Key format (should start with A3-)"
    return 1
  fi

  echo ""
  echo "Setting up 1Password account..."

  # add account using env var
  if ! OP_SECRET_KEY="$secret_key" op account add \
    --shorthand "$shorthand" \
    --address "$address" \
    --email "$email" 2>/dev/null; then
    echo "‚ùå Failed to add account. Check your credentials."
    unset password secret_key
    return 1
  fi

  # sign in
  local session_token
  if ! session_token=$(printf "%s\n" "$password" | op signin --account "$shorthand" --raw 2>/dev/null); then
    echo "‚ùå Failed to authenticate. Check your password."
    unset password secret_key
    return 1
  fi

  # store session token
  local session_file="$HOME/.config/op/1password-session.token"
  mkdir -p "$(dirname "$session_file")"
  echo "$session_token" > "$session_file"
  chmod 600 "$session_file"
  export OP_SESSION_TOKEN="$session_token"

  # clear sensitive vars
  unset password secret_key

  echo "‚úÖ 1Password CLI configured and authenticated!"
  return 0
}

# smart setup dispatcher
op-setup() {
  case "$OP_STATE" in
    authenticated)
      echo "‚úÖ Already authenticated with 1Password"
      op whoami
      ;;
    needs_login)
      echo "‚úÖ Account configured. Running login..."
      op-login
      ;;
    needs_setup)
      echo "No 1Password account configured."
      if gum confirm "Set up 1Password CLI now?" --default=true; then
        op-bootstrap
      fi
      ;;
    *)
      echo "‚ùå Unexpected state: $OP_STATE"
      return 1
      ;;
  esac
}

# interactive 1password login
op-login() {
  local SESSION_FILE="$HOME/.config/op/1password-session.token"

  # check does account exist? (we're looking for non-empty output)
  if [[ -z "$(op account list 2>/dev/null)" ]]; then
    echo "‚ö†Ô∏è  No 1Password account configured."
    if gum confirm "Set up 1Password CLI now?" --default=true; then
      op-bootstrap
      return $?
    fi
    return 1
  fi

  # try auth
  for i in {1..3}; do
    if OP_SESSION_TOKEN=$(op signin --raw 2>/dev/null); then
      mkdir -p "$(dirname "$SESSION_FILE")"
      echo "$OP_SESSION_TOKEN" > "$SESSION_FILE"
      chmod 600 "$SESSION_FILE"
      export OP_SESSION_TOKEN
      echo "‚úÖ Successfully authenticated with 1Password"
      return 0
    fi
    [[ $i -eq 3 ]] && { echo "‚ùå Authentication failed after 3 attempts."; return 1; } || echo "‚ö†Ô∏è  Attempt $i failed. Try again."
  done
}
'''

fish = '''
# source the 1password wrapper functions
test -f "$FLOX_ENV_CACHE/shell/wrapper.fish" && source "$FLOX_ENV_CACHE/shell/wrapper.fish"

function helpf
    set README_FILE "$FLOX_ENV_PROJECT/README.md"
    set README_URL "https://raw.githubusercontent.com/barstoolbluz/floxenvs/main/xplatform-cli-tools/README.md"

    if test "$argv[1]" = "--help"
        echo "Usage: helpf [OPTIONS]"
        echo ""
        echo "View environment documentation"
        echo ""
        echo "Options:"
        echo "  --force    Force download fresh copy from GitHub"
        echo "  --help     Show this help message"
        echo ""
        echo "The README is cached locally and only downloaded if missing."
        return 0
    end

    if test "$argv[1]" = "--force"
        echo "Fetching latest README.md from GitHub..."
        if curl -fsSL "$README_URL" -o "$README_FILE"
            echo "‚úì Downloaded README.md"
        else
            echo "‚úó Failed to download README.md"
            return 1
        end
    else if not test -f "$README_FILE"
        echo "README.md not found, downloading..."
        if curl -fsSL "$README_URL" -o "$README_FILE"
            echo "‚úì Downloaded README.md"
        else
            echo "‚úó Failed to download README.md"
            return 1
        end
    end

    if test -f "$README_FILE"
        bat --style=auto --paging=always "$README_FILE"
    else
        echo "‚úó README.md not found at $README_FILE"
        return 1
    end
end

# bootstrap 1password cli setup
function op-bootstrap
  gum style --border rounded "üîê 1Password CLI Setup"
  echo ""
  echo "Collect your 1Password credentials to set up CLI access."
  echo "You'll need: Sign-in address, Email, Secret Key, and Master Password"
  echo ""

  # collect creds
  set -l address (gum input --placeholder "account.1password.com" --prompt "Sign-in address: ")
  set -l email (gum input --placeholder "email@example.com" --prompt "Email: ")
  set -l secret_key (gum input --password --prompt "Secret Key (A3-XXXXXX-...): ")
  set -l password (gum input --password --prompt "Master password: ")
  set -l shorthand (gum input --placeholder "personal" --prompt "Account shorthand: " --value (echo "$address" | cut -d. -f1))

  # validate inputs
  if test -z "$address"; or test -z "$email"; or test -z "$secret_key"; or test -z "$password"
    echo "‚ùå All fields are required"
    return 1
  end

  if not string match -qr '^A3-' "$secret_key"
    echo "‚ùå Invalid Secret Key format (should start with A3-)"
    return 1
  end

  echo ""
  echo "Setting up 1Password account..."

  # add account if not exist
  if not env OP_SECRET_KEY="$secret_key" op account add --shorthand "$shorthand" --address "$address" --email "$email" 2>/dev/null
    echo "‚ùå Failed to add account. Check your credentials."
    set -e password secret_key
    return 1
  end

  # sign in
  if not set -l session_token (printf "%s\n" "$password" | op signin --account "$shorthand" --raw 2>/dev/null)
    echo "‚ùå Failed to authenticate. Check your password."
    set -e password secret_key
    return 1
  end

  # store token
  set -l session_file "$HOME/.config/op/1password-session.token"
  mkdir -p (dirname "$session_file")
  echo "$session_token" > "$session_file"
  chmod 600 "$session_file"
  set -gx OP_SESSION_TOKEN "$session_token"

  # clear sensitive vars
  set -e password secret_key

  echo "‚úÖ 1Password CLI configured and authenticated!"
  return 0
end

# smart setup dispatcher
function op-setup
  switch "$OP_STATE"
    case authenticated
      echo "‚úÖ Already authenticated with 1Password"
      op whoami
    case needs_login
      echo "‚úÖ Account configured. Running login..."
      op-login
    case needs_setup
      echo "No 1Password account configured."
      if gum confirm "Set up 1Password CLI now?" --default=true
        op-bootstrap
      end
    case '*'
      echo "‚ùå Unexpected state: $OP_STATE"
      return 1
  end
end

# interactive 1password login
function op-login
  set -l SESSION_FILE "$HOME/.config/op/1password-session.token"

  # check does account exist? (we're looking for non-empty output)
  if test -z (op account list 2>/dev/null)
    echo "‚ö†Ô∏è  No 1Password account configured."
    if gum confirm "Set up 1Password CLI now?" --default=true
      op-bootstrap
      return $status
    end
    return 1
  end

  # try auth
  for i in (seq 3)
    if set -l token (op signin --raw 2>/dev/null)
      mkdir -p (dirname "$SESSION_FILE")
      echo "$token" > "$SESSION_FILE"
      chmod 600 "$SESSION_FILE"
      set -gx OP_SESSION_TOKEN "$token"
      echo "‚úÖ Successfully authenticated with 1Password"
      return 0
    end

    if test $i -eq 3
      echo "‚ùå Authentication failed after 3 attempts."
      return 1
    else
      echo "‚ö†Ô∏è  Attempt $i failed. Try again."
    end
  end
end
'''


[options]
systems = ["aarch64-darwin", "aarch64-linux", "x86_64-darwin", "x86_64-linux"]
