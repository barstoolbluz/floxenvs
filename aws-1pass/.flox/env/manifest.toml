#
# This is a Flox environment manifest.
# Visit flox.dev/docs/concepts/manifest/
# or see flox-edit(1), manifest.toml(5) for more information.
#
version = 1

# List packages you wish to install in your environment inside
# the `[install]` section.
[install]
_1password.pkg-path = "_1password"
_1password.version = "1password-cli-2.29.0"
awscli2.pkg-path = "awscli2"
awscli2.version = "2.17.0"
gum.pkg-path = "gum"
gum.version = "0.14.1"
bat.pkg-path = "bat"
# hello.pkg-path = "hello"
# nodejs = { version = "^18.4.2", pkg-path = "nodejs_18" }

# Set environment variables in the `[vars]` section. These variables may not
# reference one another, and are added to the environment without first
# expanding them. They are available for use in the `[profile]` and `[hook]`
# scripts.
[vars]
# message = "Howdy"

# The `hook.on-activate` script is run by the *bash* shell immediately upon
# activating an environment, and will not be invoked if Flox detects that the
# environment has previously been activated. Variables set by the script will
# be inherited by `[profile]` scripts defined below. Note that any stdout
# generated by the script will be redirected to stderr.
[hook]
on-activate = '''
setup_1password_cli() {
    # Here we check to see if the config file exists and contains required strings
    check_config() {
        local config_file="$HOME/.config/op/config"
        if [[ -f "$config_file" ]]; then
            if grep -q "url" "$config_file" && grep -q "email" "$config_file" && grep -q "accountKey" "$config_file"; then
                return 0
            fi
        fi
        return 1
    }

    # Exit the shell if the user opts not to continue/maxes out 1Password authentication attempts
    exit_shell() {
        echo "Exiting the shell. Please run 'flox activate' to restart the wizard."
        exit 1
    }
    
    # Get terminal width for consistent sizing across all windows
    # Use a fixed width of 112 columns
    term_width=112
    # If terminal is narrower than our desired width, adjust accordingly
    actual_term_width=$(tput cols 2>/dev/null || echo 112)
    [[ "$actual_term_width" =~ ^[0-9]+$ ]] || actual_term_width=112
    # Don't let our boxes be wider than the terminal (minus a small margin)
    if [[ $actual_term_width -lt $term_width ]]; then
        term_width=$((actual_term_width - 4))
    fi
    
    # Check to see if the 1Password config (a) exists and (b) is valid
    # Skip setup if config exists
    if check_config; then
        return 0
    fi

    # Flox 1Password CLI Setup Wizard
    clear
    
    # Create welcome message
    welcome_message="$(gum style --foreground 141 --bold 'Welcome to the Flox 1Password CLI Setup Wizard!')

ðŸ‘‰  We'll need the following information:
    $(gum style --foreground 212 '1.') Your 1Password account URL (e.g., https://your-team.1password.com)
    $(gum style --foreground 212 '2.') Your email address associated with the 1Password account
    $(gum style --foreground 212 '3.') Your 1Password Secret Key (a 34-character code)

ðŸ‘‰  What happens next:
    $(gum style --foreground 212 'â€¢') We'll use this information to authenticate with 1Password
    $(gum style --foreground 212 'â€¢') This will bootstrap your local environment
    $(gum style --foreground 212 'â€¢') You can type 'exit' or 'quit' at any prompt to exit the wizard"
    
    # Display styled welcome message
    gum style \
        --border rounded \
        --border-foreground 240 \
        --padding "1 2" \
        --margin "1 0" \
        --width "$term_width" \
        "$welcome_message"

    # Prompt you Yes/No to continue with the 1Password CLI Bootstrapping / Setup Wizard
    if ! gum confirm "Do you want to continue?" --default=true; then
        exit_shell
    fi

    echo "Type 'exit' or 'quit' at any prompt to exit the wizard."

    # You can type 'exit' at any time to quit the wizard
    check_exit() {
        if [[ "$1" == "exit" || "$1" == "quit" ]]; then
            echo "Exiting the wizard. You can run 'flox activate' again to restart."
            exit 0
        fi
    }

    # Let's collect the infos we need to bootstrap the 1Password CLI
    address=$(gum input --prompt "Enter your 1Password account URL (or type 'exit' to quit): " --placeholder "https://" --width "$term_width")
    check_exit "$address"

    email=$(gum input --prompt "Enter your email address (or type 'exit' to quit): " --width "$term_width")
    check_exit "$email"

    secret_key=$(gum input --prompt "Enter your Secret Key (or type 'exit' to quit): " --width "$term_width")
    check_exit "$secret_key"

    # Attempt to sign in (max 5 retries)
    for attempt in {1..5}; do
        echo "Signing in to 1Password (Attempt $attempt of 5)..."
        if output=$(op account add --address "$address" --email "$email" --secret-key "$secret_key" 2>/dev/null); then
            echo "Successfully signed in to 1Password!"
            break
        else
            if [[ $attempt -eq 5 ]]; then
                echo "Maximum number of attempts reached. Authentication failed."
                exit_shell
            fi
            echo "Authentication failed. Please try again."
        fi
    done

    # Create the session file directory if it doesn't exist
    session_file="$HOME/.config/op/1password-aws.session"
    mkdir -p "$(dirname "$session_file")"
    touch "$session_file"
    chmod 600 "$session_file"
    
    echo "1Password CLI setup completed successfully."
}


# Enable (=true) or Disable (=false) 1Password session persistence
configure_1password_persistence() {
    local config_file="$HOME/.config/op/1password-aws.session"
    
    # Get terminal width for consistent sizing across all windows
    # Use a fixed width of 112 columns
    term_width=112
    # If terminal is narrower than our desired width, adjust accordingly
    actual_term_width=$(tput cols 2>/dev/null || echo 112)
    [[ "$actual_term_width" =~ ^[0-9]+$ ]] || actual_term_width=112
    # Don't let our boxes be wider than the terminal (minus a small margin)
    if [[ $actual_term_width -lt $term_width ]]; then
        term_width=$((actual_term_width - 4))
    fi
    
    # Ensure the file exists
    touch "$config_file"
    
    # Check if session persistence is already configured
    if grep -q "BEGIN 1PASSWORD SESSION PERSISTENCE CONFIGURATION" "$config_file" 2>/dev/null; then
        # Load existing settings
        source "$config_file"
        return 0
    fi

    # Create persistence message
    persistence_message="$(gum style --foreground 141 --bold 'About 1Password Session Persistence')

ðŸ‘‰  Security Details:
    $(gum style --foreground 212 'Session Token:')  Stored locally, IN PLAIN TEXT
    $(gum style --foreground 212 'Token Location:') '$HOME/.config/op/1password-aws.session'
    $(gum style --foreground 212 'Token Expiry:')   After 30 minutes of inactivity

ðŸ‘‰  Benefits of Session Persistence:
    $(gum style --foreground 212 'â€¢ Automatic Login:')      Remain logged in between terminal sessions
    $(gum style --foreground 212 'â€¢ Seamless Experience:')  No need to re-authenticate when creating new sessions
    $(gum style --foreground 212 'â€¢ Convenience:')          Exit and re-enter Flox env without logging in again"

    # Display styled message
    gum style \
        --border rounded \
        --border-foreground 240 \
        --padding "1 2" \
        --margin "1 0" \
        --width "$term_width" \
        "$persistence_message"

    gum style --foreground 141 "Do you want to enable 1Password session persistence?"
    local user_choice=$(gum choose "Yes" "No")

    if [[ "$user_choice" == "Yes" ]]; then
        ENABLE_1PASSWORD_PERSISTENCE="true"
    else
        ENABLE_1PASSWORD_PERSISTENCE="false"
    fi

    # Here we append a session persistence flag to 1password-aws.session
    {
        echo
        echo "# BEGIN 1PASSWORD SESSION PERSISTENCE CONFIGURATION"
        echo "ENABLE_1PASSWORD_PERSISTENCE=\"${ENABLE_1PASSWORD_PERSISTENCE}\""
        echo "# END 1PASSWORD SESSION PERSISTENCE CONFIGURATION"
    } >> "$config_file"

    # Set the correct file permissions
    chmod 600 "$config_file"

    echo "1Password session persistence configuration has been appended to $config_file"
}


# Function that configures 1Password/AWS CLI integration
configure_1password_aws_cli() {
    local config_file="$HOME/.config/op/1password-aws.session"

    # Get terminal width for consistent sizing across all windows
    # Use a fixed width of 112 columns
    term_width=112
    # If terminal is narrower than our desired width, adjust accordingly
    actual_term_width=$(tput cols 2>/dev/null || echo 112)
    [[ "$actual_term_width" =~ ^[0-9]+$ ]] || actual_term_width=112
    # Don't let our boxes be wider than the terminal (minus a small margin)
    if [[ $actual_term_width -lt $term_width ]]; then
        term_width=$((actual_term_width - 4))
    fi
    
    # Ensure the file exists
    touch "$config_file"
    
    # Load existing configuration
    if [[ -f "$config_file" ]]; then
        source "$config_file"
    fi

    # Check if full configuration already exists
    if grep -q "BEGIN 1PASSWORD AWS CLI CONFIGURATION" "$config_file" 2>/dev/null; then
        if grep -q "OP_VAULT" "$config_file" && grep -q "OP_AWS_CREDENTIALS" "$config_file" && grep -q "OP_AWS_USERNAME_FIELD" "$config_file" && grep -q "OP_AWS_CREDENTIALS_FIELD" "$config_file"; then
            return 0
        fi
    fi

    clear
    
    # Create AWS integration message
    aws_message="$(gum style --foreground 141 --bold '1Password AWS Integration Setup')

ðŸ‘‰  About this configuration:
    $(gum style --foreground 212 'â€¢') We DON'T store AWS credentials on your local system
    $(gum style --foreground 212 'â€¢') We obtain credentials from your 1Password vault for authentication
    $(gum style --foreground 212 'â€¢') We use ephemeral environments to pass credentials securely

ðŸ‘‰  You'll need to provide:
    $(gum style --foreground 212 '1.') The name of your 1Password vault containing AWS credentials
    $(gum style --foreground 212 '2.') The name of the item storing your AWS credentials
    $(gum style --foreground 212 '3.') The field names for your access key ID and secret access key

ðŸ‘‰  You can type 'exit' at any prompt to quit this wizard."

    # Display styled AWS integration message
    gum style \
        --border rounded \
        --border-foreground 240 \
        --padding "1 2" \
        --margin "1 0" \
        --width "$term_width" \
        "$aws_message"

    # You can exit this wizard at any time
    check_exit() {
        if [[ "$1" == "exit" ]]; then
            echo "Exiting the wizard. You can run 'flox activate' again to restart."
            exit 0
        fi
    }

    # Collect vault name with clear prompt
    gum style --foreground 141 "Enter the name of your 1Password vault containing AWS credentials:"
    while [[ -z "${OP_VAULT}" ]]; do
        OP_VAULT=$(gum input --placeholder "Vault name")
        check_exit "$OP_VAULT"
    done

    # Collect item name with clear prompt
    gum style --foreground 141 "Enter the name of the item storing your AWS credentials:"
    while [[ -z "${OP_AWS_CREDENTIALS}" ]]; do
        OP_AWS_CREDENTIALS=$(gum input --placeholder "Credentials item name")
        check_exit "$OP_AWS_CREDENTIALS"
    done

    # Collect field names for AWS credentials
    gum style --foreground 141 "Enter the field name for your AWS access key ID (default: username):"
    OP_AWS_USERNAME_FIELD=$(gum input --placeholder "username" --width "$term_width")
    check_exit "$OP_AWS_USERNAME_FIELD"
    # Set default if empty
    OP_AWS_USERNAME_FIELD=${OP_AWS_USERNAME_FIELD:-username}

    gum style --foreground 141 "Enter the field name for your AWS secret access key (default: credentials):"
    OP_AWS_CREDENTIALS_FIELD=$(gum input --placeholder "credentials" --width "$term_width")
    check_exit "$OP_AWS_CREDENTIALS_FIELD"
    # Set default if empty
    OP_AWS_CREDENTIALS_FIELD=${OP_AWS_CREDENTIALS_FIELD:-credentials}

    # Check if AWS region needs to be set
    if [[ ! -f ~/.aws/config ]] || ! grep -q "^[[:space:]]*region[[:space:]]*=" ~/.aws/config; then
        gum style --foreground 141 "Enter your AWS region (e.g., us-east-1):"
        gum style --foreground 212 "â€¢ This will be stored in your local AWS config file"
        gum style --foreground 212 "â€¢ Press Enter to skip this step if you already have a region configured"
        
        AWS_REGION=$(gum input --placeholder "AWS region" --width "$term_width")
        check_exit "$AWS_REGION"
        
        if [[ -n "$AWS_REGION" ]]; then
            if [[ $AWS_REGION =~ ^[a-z]{2}-[a-z]+-[0-9]+$ ]]; then
                mkdir -p ~/.aws
                if [[ -f ~/.aws/config ]]; then
                    sed -i '/^\[default\]/,/^$/d' ~/.aws/config 2>/dev/null || sed -i '' '/^\[default\]/,/^$/d' ~/.aws/config
                fi
                echo -e "[default]\nregion = ${AWS_REGION}" >> ~/.aws/config
                chmod 600 ~/.aws/config
            else
                gum style --foreground 9 "Invalid region format. Skipping region configuration."
            fi
        fi
    fi

    # Create a clean configuration
    temp_file=$(mktemp)
    {
        echo "# BEGIN 1PASSWORD AWS CLI CONFIGURATION"
        echo "OP_VAULT=\"${OP_VAULT}\""
        echo "OP_AWS_CREDENTIALS=\"${OP_AWS_CREDENTIALS}\""
        echo "OP_AWS_USERNAME_FIELD=\"${OP_AWS_USERNAME_FIELD}\""
        echo "OP_AWS_CREDENTIALS_FIELD=\"${OP_AWS_CREDENTIALS_FIELD}\""
        echo "# END 1PASSWORD AWS CLI CONFIGURATION"
        echo ""
        
        # Copy any other configurations (excluding the AWS CLI config)
        if [[ -f "$config_file" ]]; then
            sed '/# BEGIN 1PASSWORD AWS CLI CONFIGURATION/,/# END 1PASSWORD AWS CLI CONFIGURATION/d' "$config_file"
        fi
    } > "$temp_file"
    mv "$temp_file" "$config_file"
    chmod 600 "$config_file"

    # Show completion message
    gum style --foreground 212 "AWS CLI configuration for 1Password completed successfully."
}

# Function to authenticate with 1Password; this is called by the 'aws' alias in [profile]
authenticate_1password() {
    local config_file="$HOME/.config/op/1password-aws.session"

    [[ -f "$config_file" ]] && source "$config_file"

    if [[ "${ENABLE_1PASSWORD_PERSISTENCE}" != "true" ]]; then
        echo "1Password session persistence is not enabled. Skipping authentication."
        return 0
    fi

    # Check if the token exists and is valid
    if [[ -n "${OP_SESSION_TOKEN}" ]]; then
        if op whoami --session "${OP_SESSION_TOKEN}" >/dev/null 2>&1; then
            echo "Existing 1Password session is valid."
            return 0
        else
            echo "Existing 1Password session is invalid. Re-authenticating..."
            unset OP_SESSION_TOKEN
        fi
    else
        echo "No existing 1Password session found. Authenticating..."
    fi

    max_retries=5
    retry_count=0
    while true; do
        OP_SESSION_TOKEN=$(op signin --raw 2>&1)
        if [[ $? -eq 0 ]]; then
            # Remove the old session token and insert the new one in its place
            if grep -q "# BEGIN 1PASSWORD SESSION TOKEN" "$config_file"; then
                sed -i '/# BEGIN 1PASSWORD SESSION TOKEN/,/# END 1PASSWORD SESSION TOKEN/c\
# BEGIN 1PASSWORD SESSION TOKEN\
OP_SESSION_TOKEN="'"${OP_SESSION_TOKEN}"'"\
# END 1PASSWORD SESSION TOKEN' "$config_file" 2>/dev/null || \
                sed -i '' '/# BEGIN 1PASSWORD SESSION TOKEN/,/# END 1PASSWORD SESSION TOKEN/c\
# BEGIN 1PASSWORD SESSION TOKEN\
OP_SESSION_TOKEN="'"${OP_SESSION_TOKEN}"'"\
# END 1PASSWORD SESSION TOKEN' "$config_file"
            else
                # If the session token section doesn't exist, append it
                echo >> "$config_file"
                echo "# BEGIN 1PASSWORD SESSION TOKEN" >> "$config_file"
                echo "OP_SESSION_TOKEN=\"${OP_SESSION_TOKEN}\"" >> "$config_file"
                echo "# END 1PASSWORD SESSION TOKEN" >> "$config_file"
            fi
            
            echo "Authentication successful."
            break
        else
            retry_count=$((retry_count + 1))
            if [[ ${retry_count} -ge ${max_retries} ]]; then
                echo "Maximum number of retries exceeded. Please check your 1Password credentials and try again."
                return 1
            else
                echo "Invalid password. Please try again."
            fi
        fi
    done

    # Here we export the OP_SESSION_TOKEN for use in the current session
    export OP_SESSION_TOKEN
}

# Main execution flow
main() {
    # Set up 1Password CLI
    setup_1password_cli
    
    # Configure persistence preferences
    configure_1password_persistence
    
    # Configure AWS CLI integration
    configure_1password_aws_cli
    
    # Authenticate and get a session token
    authenticate_1password
    
    # Export session token for use in profile scripts
    export OP_SESSION_TOKEN
}

# Execute main function
main
'''

# The `profile.common` script is sourced by all shells and special care should be
# taken to ensure compatibility with all shells, after which exactly one of
# `profile.{bash,fish,tcsh,zsh}` is sourced by the corresponding shell.
[profile]
common = '''
# Source the 1password-aws.session file
[[ -f $HOME/.config/op/1password-aws.session ]] && source $HOME/.config/op/1password-aws.session

# AWS CLI alias
alias aws='op run --session "${OP_SESSION_TOKEN}" --env-file <(printf "%s\n" AWS_ACCESS_KEY_ID=op://${OP_VAULT}/${OP_AWS_CREDENTIALS}/${OP_AWS_USERNAME_FIELD} AWS_SECRET_ACCESS_KEY=op://${OP_VAULT}/${OP_AWS_CREDENTIALS}/${OP_AWS_CREDENTIALS_FIELD}) -- aws'
'''

# Additional options can be set in the `[options]` section. Refer to
# manifest.toml(5) for a list of available options.
[options]
systems = ["aarch64-darwin", "aarch64-linux", "x86_64-darwin", "x86_64-linux"]
